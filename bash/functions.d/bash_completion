#
#   The content of this file is part of the bash_completion project. The
#   original copyright notice is provided below.
#
#
#
#   bash_completion - programmable completion functions for bash 3.2+
#
#   Copyright © 2006-2008, Ian Macdonald <ian@caliban.org>
#             © 2009-2010, Bash Completion Maintainers
#                     <bash-completion-devel@lists.alioth.debian.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2, or (at your option)
#   any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software Foundation,
#   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#   The latest version of this software can be obtained here:
#
#   http://bash-completion.alioth.debian.org/
#
#   RELEASE: 1.1

if ! type -t _get_comp_words_by_ref; then
  # Get the word to complete and optional previous words.
  # This is nicer than ${COMP_WORDS[$COMP_CWORD]}, since it handles cases
  # where the user is completing in the middle of a word.
  # (For example, if the line is "ls foobar",
  # and the cursor is here -------->   ^
  # Also one is able to cross over possible wordbreak characters.
  # Usage: _get_comp_words_by_ref [OPTIONS] [VARNAMES]
  # Available VARNAMES:
  #     cur         Return cur via $cur
  #     prev        Return prev via $prev
  #     words       Return words via $words
  #     cword       Return cword via $cword
  #
  # Available OPTIONS:
  #     -n EXCLUDE  Characters out of $COMP_WORDBREAKS which should NOT be 
  #                 considered word breaks. This is useful for things like scp
  #                 where we want to return host:path and not only path, so we
  #                 would pass the colon (:) as -n option in this case.  Bash-3
  #                 doesn't do word splitting, so this ensures we get the same
  #                 word on both bash-3 and bash-4.
  #     -c VARNAME  Return cur via $VARNAME
  #     -p VARNAME  Return prev via $VARNAME
  #     -w VARNAME  Return words via $VARNAME
  #     -i VARNAME  Return cword via $VARNAME
  #
  # Example usage:
  #
  #    $ _get_comp_words_by_ref -n : cur prev
  #
  _get_comp_words_by_ref()
  {
      local exclude flag i OPTIND=1
      local cur cword words=()
      local upargs=() upvars=() vcur vcword vprev vwords

      while getopts "c:i:n:p:w:" flag "$@"; do
          case $flag in
              c) vcur=$OPTARG ;;
              i) vcword=$OPTARG ;;
              n) exclude=$OPTARG ;;
              p) vprev=$OPTARG ;;
              w) vwords=$OPTARG ;;
          esac
      done
      while [[ $# -ge $OPTIND ]]; do 
          case ${!OPTIND} in
              cur)   vcur=cur ;;
              prev)  vprev=prev ;;
              cword) vcword=cword ;;
              words) vwords=words ;;
              *) echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" \
                  1>&2; return 1
          esac
          let "OPTIND += 1"
      done

      __get_cword_at_cursor_by_ref "$exclude" words cword cur

      [[ $vcur   ]] && { upvars+=("$vcur"  ); upargs+=(-v $vcur   "$cur"  ); }
      [[ $vcword ]] && { upvars+=("$vcword"); upargs+=(-v $vcword "$cword"); }
      [[ $vprev  ]] && { upvars+=("$vprev" ); upargs+=(-v $vprev 
          "${words[cword - 1]}"); }
      [[ $vwords ]] && { upvars+=("$vwords"); upargs+=(-a${#words[@]} $vwords
          "${words[@]}"); }

      (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
  }
fi